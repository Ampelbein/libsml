Description: Upstream changes introduced in version 0.1-5~wip
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 libsml (0.1-5~wip) unstable; urgency=low
 .
   * Adapted sml_transport_ for vzlogger
 .
 The person named in the Author field signed this changelog entry.
Author: Steffen Vogel <info@steffenvogel.de>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- libsml-0.1.orig/sml/include/sml/sml_shared.h
+++ libsml-0.1/sml/include/sml/sml_shared.h
@@ -106,8 +106,8 @@ void sml_buf_update_bytes_read(sml_buffe
 
 // Checks if the next field is a skipped optional field, updates the buffer accordingly
 int sml_buf_optional_is_skipped(sml_buffer *buf);
-#define SML_SKIP_OPTIONAL (sml_buf_optional_is_skipped(buf)) ? 0 :
 
+// Prints arbitrarily byte string to stdout with printf
 void hexdump(unsigned char *buffer, size_t buffer_len);
 
 #ifdef __cplusplus
--- libsml-0.1.orig/sml/include/sml/sml_transport.h
+++ libsml-0.1/sml/include/sml/sml_transport.h
@@ -26,12 +26,14 @@
 extern "C" {
 #endif
 
-// sml_transport_listen reads continously bytes from fd and scans 
+// sml_transport_read reads continously bytes from fd and scans 
 // for the SML transport protocol escape sequences. If a SML file
-// is detected, the sml_transporter_receiver is called with the 
-// complete bytes, including the escape sequences.
-// The buffer is free'd after the sml_transport_receiver comes 
-// back.
+// is detected it will be copied into the buffer. The total amount of bytes read
+// will be returned. If the SML file exceeds the len of the buffer, -1 will be returned
+size_t sml_transport_read(int fd, unsigned char *buffer, size_t max_len);
+
+// sml_transport_listen is an endless loop which reads continously
+// via sml_transport_read and calls the sml_transporter_receiver
 void sml_transport_listen(int fd, void (*sml_transport_receiver)(unsigned char *buffer, size_t buffer_len));
 
 // sml_transport_writes adds the SML transport protocol escape 
--- libsml-0.1.orig/sml/src/sml_list.c
+++ libsml-0.1/sml/src/sml_list.c
@@ -60,7 +60,7 @@ sml_list *sml_list_entry_parse(sml_buffe
 	l->status = sml_status_parse(buf);
 	if (sml_buf_has_errors(buf)) goto error;
 
-	l->val_time = SML_SKIP_OPTIONAL sml_time_parse(buf);
+	l->val_time = sml_time_parse(buf);
 	if (sml_buf_has_errors(buf)) goto error;
 	
 	l->unit = sml_u8_parse(buf);
--- libsml-0.1.orig/sml/src/sml_transport.c
+++ libsml-0.1/sml/src/sml_transport.c
@@ -29,17 +29,17 @@
 
 #define MC_SML_BUFFER_LEN 8096
 
-void sml_transport_listen(int fd, void (*sml_transport_receiver)(unsigned char *buffer, size_t buffer_len)) {
+size_t sml_transport_read(int fd, unsigned char *buffer, size_t max_len) {
 
 	fd_set readfds;
 	FD_ZERO(&readfds);
 	FD_SET(fd, &readfds);
 	
 	unsigned char byte;
-	unsigned char buf[MC_SML_BUFFER_LEN];
-	int esc = 0, start = 0, i, end = 0, r;
+	unsigned char buf[max_len];
+	int esc = 0, start = 0, i = 0, end = 0, r;
 	
-	for (i = 0; i < MC_SML_BUFFER_LEN;) {
+	while (i < max_len) {
 		select(fd + 1, &readfds, 0, 0, 0);
 		if (FD_ISSET(fd, &readfds)) {
             
@@ -79,13 +79,8 @@ void sml_transport_listen(int fd, void (
 					if (end) {
 						end++;
 						if (end == 5) {
-							char *sml_file = (char *) malloc(i);
-							memcpy(sml_file, &(buf[0]), i);
-							sml_transport_receiver((unsigned char *)(sml_file), i);
-							free(sml_file);
-							i = -1;
-							esc = 0;
-							end = 0;
+							memcpy(buffer, &(buf[0]), i);
+							return i;
 						}
 					}
 					else {
@@ -111,7 +106,21 @@ void sml_transport_listen(int fd, void (
 			}
 		}
 	}
-	printf("error: no end sequence found, buffer full.");
+	
+	return -1;
+}
+
+void sml_transport_listen(int fd, void (*sml_transport_receiver)(unsigned char *buffer, size_t buffer_len)) {
+	unsigned char buffer[MC_SML_BUFFER_LEN];
+	size_t bytes;
+	
+	while (1) {
+		bytes = sml_transport_read(fd, buffer, MC_SML_BUFFER_LEN);
+		
+		if (bytes > 0) {
+			sml_transport_receiver(buffer, bytes);
+		}
+	}
 }
 
 int sml_transport_write(int fd, sml_file *file) {
